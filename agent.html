<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>üü£ Ultimate Agent v3.1 (Stable)</title>
    <style>
        body { font-family: 'Courier New', monospace; background: #050505; color: #a48eff; padding: 20px; max-width: 900px; margin: 0 auto; }
        .panel { background: #111; padding: 20px; border: 1px solid #333; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 0 20px rgba(164, 142, 255, 0.1); }
        h1 { border-bottom: 1px solid #333; padding-bottom: 10px; color: #fff; text-transform: uppercase; letter-spacing: 2px; }
        input, select { background: #000; color: #fff; border: 1px solid #444; padding: 12px; width: 100%; box-sizing: border-box; margin-top: 5px; font-family: monospace; }
        label { font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-top: 15px; display: block; font-weight: bold; }
        button { background: #a48eff; color: #000; border: none; padding: 15px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 20px; font-size: 16px; transition: 0.2s; text-transform: uppercase; }
        button:hover { background: #fff; box-shadow: 0 0 15px #a48eff; }
        .log { height: 400px; overflow-y: auto; font-size: 13px; border: 1px solid #333; padding: 15px; background: #000; margin-top: 20px; white-space: pre-wrap; }
        .status-bar { display: flex; justify-content: space-between; font-size: 12px; color: #555; margin-bottom: 10px; }
        .dot { height: 8px; width: 8px; background: #333; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .dot.active { background: #0f0; box-shadow: 0 0 5px #0f0; }
    </style>
</head>
<body>
    <h1>üü£ Ultimate Agent <span style="font-size:12px; color:#666;">v3.1</span></h1>
    <div class="status-bar">
        <span><span id="netDot" class="dot"></span> NETWORK</span>
        <span><span id="memDot" class="dot"></span> MEMORY</span>
        <span><span id="voiceDot" class="dot"></span> VOICE</span>
    </div>

    <div class="panel">
        <label>1. Blockchain Network</label>
        <select id="network" onchange="updateNetwork()">
            <option value="testnet" selected>üü¢ Testnet (Free / Dev)</option>
            <option value="mainnet">üî¥ Mainnet (Real Money)</option>
        </select>

        <label>2. Security Keys</label>
        <input type="text" id="algoAddress" placeholder="Your Wallet Address (Watcher)">
        <input type="password" id="secretPass" placeholder="Encryption Password (Matches Sender)">

        <label>3. Artificial Intelligence</label>
        <select id="provider">
            <option value="gemini">Google Gemini (Fast/Free)</option>
            <option value="openai">OpenAI (GPT-4o)</option>
            <option value="grok">xAI Grok</option>
        </select>
        <input type="password" id="apiKey" placeholder="Paste API Key here">
    </div>

    <button onclick="startAgent()">üöÄ INITIALIZE SYSTEM</button>
    <div class="log" id="consoleOutput"></div>

    <script type="module">
        let INDEXER_URL = "https://testnet-idx.algonode.cloud";
        let lastRound = 0;
        let isProcessing = false;
        let pollIntervalId = null;
        let dirHandle;
        let memoryContent = "User Name: Owner. Preferences: None.";

        // --- 1. VOICE SYNTHESIS (TTS) ---
        function speak(text) {
            if (!window.speechSynthesis) return;
            const cleanText = text.replace(/```[\s\S]*?```/g, "Code block generated.").substring(0, 200); 
            const utter = new SpeechSynthesisUtterance(cleanText);
            utter.rate = 1.1; 
            utter.pitch = 0.9;
            window.speechSynthesis.speak(utter);
            document.getElementById('voiceDot').classList.add('active');
            utter.onend = () => document.getElementById('voiceDot').classList.remove('active');
        }

        // --- 2. CRYPTO UTILS ---
        async function deriveKey(password) {
            const enc = new TextEncoder();
            const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
            return window.crypto.subtle.deriveKey({ name: "PBKDF2", salt: enc.encode("somesalt"), iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
        }

        async function decryptMessage(encryptedBase64, password) {
            try {
                const key = await deriveKey(password);
                const rawData = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
                const iv = rawData.slice(0, 12);
                const ciphertext = rawData.slice(12);
                const decryptedBuffer = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, ciphertext);
                return new TextDecoder().decode(decryptedBuffer);
            } catch (e) { return null; }
        }

        // --- 3. FILE SYSTEM & MEMORY ---
        async function loadMemory() {
            try {
                const fileHandle = await dirHandle.getFileHandle('memory.txt');
                const file = await fileHandle.getFile();
                memoryContent = await file.text();
                document.getElementById('memDot').classList.add('active');
                log("üß† Memory Loaded.");
            } catch (e) {
                log("‚ö†Ô∏è Memory new/empty. Creating...");
            }
        }

        async function saveMemory(newMem) {
            if (!newMem) return;
            const fileHandle = await dirHandle.getFileHandle('memory.txt', { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(newMem);
            await writable.close();
            memoryContent = newMem;
            document.getElementById('memDot').classList.add('active');
            log("üß† Memory Updated.");
        }

        async function injectFiles(prompt) {
            // Regex Fix: Handles spaces like {{ file.txt }}
            const regex = /\{\{\s*([^}]+)\s*\}\}/g;
            let newPrompt = prompt;
            const matches = [...prompt.matchAll(regex)];

            for (const m of matches) {
                const placeholder = m[0];
                const filename = m[1].trim();
                try {
                    log(`üìñ Reading local file: ${filename}...`);
                    const fileHandle = await dirHandle.getFileHandle(filename);
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    const safeContent = content.substring(0, 20000); 
                    newPrompt = newPrompt.replace(placeholder, `\n[CONTENT OF ${filename}]:\n${safeContent}\n[END FILE]\n`);
                } catch (e) {
                    newPrompt = newPrompt.replace(placeholder, "(System: File not found)");
                }
            }
            return newPrompt;
        }

        // --- 4. SCHEDULER (AUTONOMY) ---
        async function checkSchedule() {
            try {
                const handle = await dirHandle.getFileHandle('schedule.json');
                const file = await handle.getFile();
                const json = JSON.parse(await file.text()); 
                
                const now = new Date();
                const timeStr = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
                const dateStr = now.toDateString();
                
                // Logic Fix: Only run if it hasn't run TODAY
                if (json[timeStr] && json[timeStr].lastRun !== dateStr) {
                    log(`‚è∞ Scheduled Task Triggered: ${timeStr}`);
                    
                    // Mark as run immediately to prevent double-fire
                    json[timeStr].lastRun = dateStr;
                    const writable = await handle.createWritable();
                    await writable.write(JSON.stringify(json, null, 2));
                    await writable.close();

                    // Execute
                    await runAI("Execute scheduled task: " + json[timeStr].command);
                }
            } catch (e) { /* No schedule file, ignore */ }
        }

        // --- 5. CORE LOGIC ---
        window.updateNetwork = () => {
            const net = document.getElementById('network').value;
            INDEXER_URL = `https://${net}-idx.algonode.cloud`;
            document.getElementById('netDot').classList.add('active');
            log(`üì° Switched to ${net.toUpperCase()}`);
        };

        window.log = (msg) => {
            const d = document.getElementById('consoleOutput');
            d.innerHTML = `<div><span style="color:#555">[${new Date().toLocaleTimeString()}]</span> ${msg}</div>` + d.innerHTML;
        };

        window.startAgent = async () => {
            const address = document.getElementById('algoAddress').value;
            const pass = document.getElementById('secretPass').value;
            const key = document.getElementById('apiKey').value;

            if (!address || !pass || !key) return alert("Please fill all fields.");

            try {
                dirHandle = await window.showDirectoryPicker();
                log("üìÇ Storage Access Granted");
                await loadMemory();
            } catch (e) { return alert("File access required!"); }

            try {
                const res = await fetch(`${INDEXER_URL}/v2/accounts/${address}/transactions?limit=1`);
                const data = await res.json();
                if(data.transactions && data.transactions.length > 0) {
                    lastRound = data.transactions[0]['confirmed-round'];
                }
            } catch(e) { log("‚ö†Ô∏è New wallet detected or network error. Starting fresh."); }

            log(`‚úÖ Agent Online. Listening on ${document.getElementById('network').value}...`);
            speak("System Online.");
            
            // Loop (avoid multiple intervals if re-initialized)
            if (pollIntervalId) {
                clearInterval(pollIntervalId);
            }
            pollIntervalId = setInterval(() => {
                checkBlockchain(address, pass);
                checkSchedule();
            }, 5000);
        };

        async function checkBlockchain(address, password) {
            if (isProcessing) return;
            try {
                const res = await fetch(`${INDEXER_URL}/v2/accounts/${address}/transactions?limit=5&min-round=${lastRound + 1}`);
                const data = await res.json();
                if (!data.transactions?.length) return;

                // Process oldest-to-newest to avoid skipping messages
                const sorted = [...data.transactions].sort((a, b) => a['confirmed-round'] - b['confirmed-round']);
                for (const tx of sorted) {
                    lastRound = Math.max(lastRound, tx['confirmed-round'] || lastRound);
                    if (!tx.note) continue;
                    const rawNote = atob(tx.note);
                    log(`üîç Signal Detected. Decrypting...`);
                    const cleanCommand = await decryptMessage(rawNote, password);

                    if (cleanCommand && cleanCommand.startsWith("cmd:")) {
                        await runAI(cleanCommand.replace("cmd:", "").trim());
                    }
                }
            } catch (e) { console.error(e); }
        }

        async function runAI(rawPrompt) {
            isProcessing = true;
            const apiKey = document.getElementById('apiKey').value;
            const provider = document.getElementById('provider').value;
            
            let prompt = await injectFiles(rawPrompt);
            
            const systemPrompt = `You are an autonomous AI Agent. 
            MEMORY: ${memoryContent}
            RULES: 
            1. If asking to remember, output "MEMORY_UPDATE: [new memory content]". 
            2. If code requested, output ONLY code.
            3. If schedule requested, output JSON {"HH:MM": {"command": "...", "lastRun": ""}} saved as schedule.json.`;

            log(`üß† Thinking...`);

            try {
                let text = "";
                if (provider === 'gemini') {
                    const req = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ contents: [{ parts: [{ text: systemPrompt + "\nUSER: " + prompt }] }] })
                    });
                    const res = await req.json();
                    text = res?.candidates?.[0]?.content?.parts?.[0]?.text || "";
                } else {
                    const endpoint = provider === 'grok' ? 'https://api.grok.x.ai/v1/chat/completions' : 'https://api.openai.com/v1/chat/completions';
                    const model = provider === 'grok' ? 'grok-beta' : 'gpt-4o';
                    const req = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({
                            model: model,
                            messages: [{role: "system", content: systemPrompt}, {role: "user", content: prompt}]
                        })
                    });
                    const res = await req.json();
                    text = res?.choices?.[0]?.message?.content || "";
                }

                if (!text) {
                    throw new Error("AI response was empty or malformed.");
                }

                if (text.includes("MEMORY_UPDATE:")) {
                    const newMem = text.split("MEMORY_UPDATE:")[1].trim();
                    await saveMemory(newMem);
                    text = "Memory updated successfully.";
                }

                // Smart Save
                let ext = "txt";
                const t = text.trim();
                if (t.startsWith("<!DOCTYPE") || t.startsWith("<html")) ext = "html";
                else if (t.includes("import ") || t.includes("function ") || t.includes("const ")) ext = "js";
                else if (t.includes("{") && t.includes("}")) ext = "json"; 

                const fname = `output_${Date.now()}.${ext}`;
                const fh = await dirHandle.getFileHandle(fname, { create: true });
                const w = await fh.createWritable();
                await w.write(text);
                await w.close();
                
                log(`‚úÖ Action Complete. Saved: ${fname}`);
                speak("Task complete.");

            } catch (e) { log(`‚ùå Error: ${e.message}`); }
            isProcessing = false;
        }
    </script>
</body>
</html>
